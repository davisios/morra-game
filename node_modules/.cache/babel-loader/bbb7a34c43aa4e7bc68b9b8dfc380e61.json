{"ast":null,"code":"const debug = require('debug')('wait-port');\n\nconst net = require('net');\n\nconst outputFunctions = require('./output-functions');\n\nconst validateParameters = require('./validate-parameters');\n\nconst ConnectionError = require('./errors/connection-error');\n\nfunction createConnectionWithTimeout(_ref, timeout, callback) {\n  let {\n    host,\n    port\n  } = _ref;\n  //  Variable to hold the timer we'll use to kill the socket if we don't\n  //  connect in time.\n  let timer = null; //  Try and open the socket, with the params and callback.\n\n  const socket = net.createConnection({\n    host,\n    port\n  }, err => {\n    if (!err) clearTimeout(timer);\n    return callback(err);\n  }); //  TODO: Check for the socket ECONNREFUSED event.\n\n  socket.on('error', error => {\n    debug(`Socket error: ${error}`);\n    clearTimeout(timer);\n    socket.destroy();\n    callback(error);\n  }); //  Kill the socket if we don't open in time.\n\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout trying to open socket to ${host}:${port}`);\n    error.code = 'ECONNTIMEOUT';\n    callback(error);\n  }, timeout); //  Return the socket.\n\n  return socket;\n}\n\nfunction checkHttp(socket, params, timeout, callback) {\n  //  Create the HTTP request.\n  const request = `GET ${params.path} HTTP/1.1\\r\\nHost: ${params.host}\\r\\n\\r\\n`;\n  let timer = null;\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout waiting for data from ${params.host}:${params.port}`);\n    error.code = 'EREQTIMEOUT';\n    callback(error);\n  }, timeout); //  Get ready for a response.\n\n  socket.on('data', function (data) {\n    //  Get the response as text.\n    const response = data.toString();\n    const statusLine = response.split('\\n')[0]; //  Stop the timer.\n\n    clearTimeout(timer); //  Check the data. Remember an HTTP response is:\n    //  HTTP/1.1 XXX Stuff\n\n    const statusLineParts = statusLine.split(' ');\n\n    if (statusLineParts < 2 || statusLineParts[1].startsWith('2') === false) {\n      debug(`Invalid HTTP status line: ${statusLine}`);\n      const error = new Error('Invalid response from server');\n      error.code = 'ERESPONSE';\n      callback(error);\n    } //  ALL good!\n\n\n    debug(`Successful HTTP status line: ${statusLine}`);\n    callback();\n  }); //  Send the request.\n\n  socket.write(request);\n} //  This function attempts to open a connection, given a limited time window.\n//  This is the function which we will run repeatedly until we connect.\n\n\nfunction tryConnect(options, timeout) {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = createConnectionWithTimeout(options, timeout, err => {\n        if (err) {\n          if (err.code === 'ECONNREFUSED') {\n            //  We successfully *tried* to connect, so resolve with false so\n            //  that we try again.\n            debug('Socket not open: ECONNREFUSED');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNTIMEOUT') {\n            //  We've successfully *tried* to connect, but we're timing out\n            //  establishing the connection. This is not ideal (either\n            //  the port is open or it ain't).\n            debug('Socket not open: ECONNTIMEOUT');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNRESET') {\n            //  This can happen if the target server kills its connection before\n            //  we can read from it, we can normally just try again.\n            debug('Socket not open: ECONNRESET');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ENOTFOUND') {\n            //  This will occur if the address is not found, i.e. due to a dns\n            //  lookup fail (normally a problem if the domain is wrong).\n            debug('Socket cannot be opened: ENOTFOUND');\n            socket.destroy(); //  If we are going to wait for DNS records, we can actually just try\n            //  again...\n\n            if (options.waitForDns === true) return resolve(false); // ...otherwise, we will explicitly fail with a meaningful error for\n            //  the user.\n\n            return reject(new ConnectionError(`The address '${options.host}' cannot be found`));\n          } //  Trying to open the socket has resulted in an error we don't\n          //  understand. Better give up.\n\n\n          debug(`Unexpected error trying to open socket: ${err}`);\n          socket.destroy();\n          return reject(err);\n        } //  Boom, we connected!\n\n\n        debug('Socket connected!'); //  If we are not dealing with http, we're done.\n\n        if (options.protocol !== 'http') {\n          //  Disconnect, stop the timer and resolve.\n          socket.destroy();\n          return resolve(true);\n        } //  TODO: we should only use the portion of the timeout for this interval which is still left to us.\n        //  Now we've got to wait for a HTTP response.\n\n\n        checkHttp(socket, options, timeout, err => {\n          if (err) {\n            if (err.code === 'EREQTIMEOUT') {\n              debug('HTTP error: EREQTIMEOUT');\n              socket.destroy();\n              return resolve(false);\n            } else if (err.code === 'ERESPONSE') {\n              debug('HTTP error: ERESPONSE');\n              socket.destroy();\n              return resolve(false);\n            }\n\n            debug(`Unexpected error checking http response: ${err}`);\n            socket.destroy();\n            return reject(err);\n          }\n\n          socket.destroy();\n          return resolve(true);\n        });\n      });\n    } catch (err) {\n      //  Trying to open the socket has resulted in an exception we don't\n      //  understand. Better give up.\n      debug(`Unexpected exception trying to open socket: ${err}`);\n      return reject(err);\n    }\n  });\n}\n\nfunction waitPort(params) {\n  return new Promise((resolve, reject) => {\n    const {\n      protocol,\n      host,\n      port,\n      path,\n      interval,\n      timeout,\n      output,\n      waitForDns\n    } = validateParameters(params); //  Keep track of the start time (needed for timeout calcs).\n\n    const startTime = new Date(); //  Don't wait for more than connectTimeout to try and connect.\n\n    const connectTimeout = 1000; //  Grab the object for output.\n\n    const outputFunction = outputFunctions[output];\n    outputFunction.starting({\n      host,\n      port\n    }); //  Start trying to connect.\n\n    const loop = () => {\n      outputFunction.tryConnect();\n      tryConnect({\n        protocol,\n        host,\n        port,\n        path,\n        waitForDns\n      }, connectTimeout).then(open => {\n        debug(`Socket status is: ${open}`); //  The socket is open, we're done.\n\n        if (open) {\n          outputFunction.connected();\n          return resolve(true);\n        } //  If we have a timeout, and we've passed it, we're done.\n\n\n        if (timeout && new Date() - startTime > timeout) {\n          outputFunction.timeout();\n          return resolve(false);\n        } //  Run the loop again.\n\n\n        return setTimeout(loop, interval);\n      }).catch(err => {\n        debug(`Unhandled error occured trying to connect: ${err}`);\n        return reject(err);\n      });\n    }; //  Start the loop.\n\n\n    loop();\n  });\n}\n\nmodule.exports = waitPort;","map":{"version":3,"names":["debug","require","net","outputFunctions","validateParameters","ConnectionError","createConnectionWithTimeout","timeout","callback","host","port","timer","socket","createConnection","err","clearTimeout","on","error","destroy","setTimeout","Error","code","checkHttp","params","request","path","data","response","toString","statusLine","split","statusLineParts","startsWith","write","tryConnect","options","Promise","resolve","reject","waitForDns","protocol","waitPort","interval","output","startTime","Date","connectTimeout","outputFunction","starting","loop","then","open","connected","catch","module","exports"],"sources":["/Users/david/reach/morra/morraUI/node_modules/wait-port/lib/wait-port.js"],"sourcesContent":["const debug = require('debug')('wait-port');\nconst net = require('net');\nconst outputFunctions = require('./output-functions');\nconst validateParameters = require('./validate-parameters');\nconst ConnectionError = require('./errors/connection-error');\n\nfunction createConnectionWithTimeout({ host, port }, timeout, callback) {\n  //  Variable to hold the timer we'll use to kill the socket if we don't\n  //  connect in time.\n  let timer = null;\n\n  //  Try and open the socket, with the params and callback.\n  const socket = net.createConnection({ host, port }, (err) => {\n    if (!err) clearTimeout(timer);\n    return callback(err);\n  });\n\n  //  TODO: Check for the socket ECONNREFUSED event.\n  socket.on('error', (error) => {\n    debug(`Socket error: ${error}`);\n    clearTimeout(timer);\n    socket.destroy();\n    callback(error);\n  });\n\n  //  Kill the socket if we don't open in time.\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout trying to open socket to ${host}:${port}`);\n    error.code = 'ECONNTIMEOUT';\n    callback(error);\n  }, timeout);\n\n  //  Return the socket.\n  return socket;\n}\n\nfunction checkHttp(socket, params, timeout, callback) {\n  //  Create the HTTP request.\n  const request = `GET ${params.path} HTTP/1.1\\r\\nHost: ${params.host}\\r\\n\\r\\n`;\n\n  let timer = null;\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout waiting for data from ${params.host}:${params.port}`);\n    error.code = 'EREQTIMEOUT';\n    callback(error);\n  }, timeout);\n\n  //  Get ready for a response.\n  socket.on('data', function(data) {\n    //  Get the response as text.\n    const response = data.toString();\n    const statusLine = response.split('\\n')[0];\n\n    //  Stop the timer.\n    clearTimeout(timer);\n\n    //  Check the data. Remember an HTTP response is:\n    //  HTTP/1.1 XXX Stuff\n    const statusLineParts = statusLine.split(' ');\n    if (statusLineParts < 2 || statusLineParts[1].startsWith('2') === false) {\n      debug(`Invalid HTTP status line: ${statusLine}`);\n      const error = new Error('Invalid response from server');\n      error.code = 'ERESPONSE';\n      callback(error);\n    }\n\n    //  ALL good!\n    debug(`Successful HTTP status line: ${statusLine}`);\n    callback();\n  });\n\n  //  Send the request.\n  socket.write(request);\n}\n\n//  This function attempts to open a connection, given a limited time window.\n//  This is the function which we will run repeatedly until we connect.\nfunction tryConnect(options, timeout) {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = createConnectionWithTimeout(options, timeout, (err) => {\n        if (err) {\n          if (err.code === 'ECONNREFUSED') {\n            //  We successfully *tried* to connect, so resolve with false so\n            //  that we try again.\n            debug('Socket not open: ECONNREFUSED');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNTIMEOUT') {\n            //  We've successfully *tried* to connect, but we're timing out\n            //  establishing the connection. This is not ideal (either\n            //  the port is open or it ain't).\n            debug('Socket not open: ECONNTIMEOUT');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNRESET') {\n            //  This can happen if the target server kills its connection before\n            //  we can read from it, we can normally just try again.\n            debug('Socket not open: ECONNRESET');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ENOTFOUND') {\n            //  This will occur if the address is not found, i.e. due to a dns\n            //  lookup fail (normally a problem if the domain is wrong).\n            debug('Socket cannot be opened: ENOTFOUND');\n            socket.destroy();\n\n            //  If we are going to wait for DNS records, we can actually just try\n            //  again...\n            if (options.waitForDns === true) return resolve(false);\n\n            // ...otherwise, we will explicitly fail with a meaningful error for\n            //  the user.\n            return reject(new ConnectionError(`The address '${options.host}' cannot be found`));\n          }\n\n          //  Trying to open the socket has resulted in an error we don't\n          //  understand. Better give up.\n          debug(`Unexpected error trying to open socket: ${err}`);\n          socket.destroy();\n          return reject(err);\n        }\n      \n        //  Boom, we connected!\n        debug('Socket connected!');\n\n        //  If we are not dealing with http, we're done.\n        if (options.protocol !== 'http') {\n          //  Disconnect, stop the timer and resolve.\n          socket.destroy();\n          return resolve(true);\n        }\n\n        //  TODO: we should only use the portion of the timeout for this interval which is still left to us.\n\n        //  Now we've got to wait for a HTTP response.\n        checkHttp(socket, options, timeout, (err) => {\n          if (err) {\n            if (err.code === 'EREQTIMEOUT') {\n              debug('HTTP error: EREQTIMEOUT');\n              socket.destroy();\n              return resolve(false);\n            } else if (err.code === 'ERESPONSE') {\n              debug('HTTP error: ERESPONSE');\n              socket.destroy();\n              return resolve(false);\n            }\n            debug(`Unexpected error checking http response: ${err}`);\n            socket.destroy();\n            return reject(err);\n          }\n\n          socket.destroy();\n          return resolve(true);\n        });\n      });\n    } catch (err) {\n      //  Trying to open the socket has resulted in an exception we don't\n      //  understand. Better give up.\n      debug(`Unexpected exception trying to open socket: ${err}`);\n      return reject(err);\n    }\n  });\n}\n\nfunction waitPort(params) {\n  return new Promise((resolve, reject) => {\n    const {\n      protocol,\n      host,\n      port,\n      path,\n      interval,\n      timeout,\n      output,\n      waitForDns,\n    } = validateParameters(params);\n\n    //  Keep track of the start time (needed for timeout calcs).\n    const startTime = new Date();\n\n    //  Don't wait for more than connectTimeout to try and connect.\n    const connectTimeout = 1000;\n\n    //  Grab the object for output.\n    const outputFunction = outputFunctions[output];\n    outputFunction.starting({ host, port });\n\n    //  Start trying to connect.\n    const loop = () => {\n      outputFunction.tryConnect();\n      tryConnect({ protocol, host, port, path, waitForDns }, connectTimeout)\n        .then((open) => {\n          debug(`Socket status is: ${open}`);\n\n          //  The socket is open, we're done.\n          if (open) {\n            outputFunction.connected();\n            return resolve(true);\n          }\n\n          //  If we have a timeout, and we've passed it, we're done.\n          if (timeout && (new Date() - startTime) > timeout) {\n            outputFunction.timeout();\n            return resolve(false);\n          }\n\n          //  Run the loop again.\n          return setTimeout(loop, interval);\n        })\n        .catch((err) => {\n          debug(`Unhandled error occured trying to connect: ${err}`);\n          return reject(err);\n        });\n    };\n\n    //  Start the loop.\n    loop();\n  });\n}\n\nmodule.exports = waitPort;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}